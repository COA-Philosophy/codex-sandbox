// path: app/api/tools/call/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import crypto from 'node:crypto'
import { 
  auditLog, 
  generateRequestId, 
  checkIdempotency, 
  saveIdempotencyResponse,
  type LogContext 
} from '@/lib/logging/orchestra'

// Service Roleクライアント（既存方式継続）
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
)

// APIキー・スコープ管理
type Scope = 'archive:write' | 'archive:read' | 'board:read' | 'board:write' | 'logs:write'

interface ApiKeyConfig {
  [key: string]: Scope[]
}

interface ApiKeyData {
  id: string
  scopes: string[]
  projects: string[]
  name: string
}

interface RateLimitResult {
  allowed: boolean
  remaining: number
  resetTime: Date
  limit: number
}

function getApiKeyConfig(): ApiKeyConfig | null {
  const configJson = process.env.MCP_API_KEYS_JSON
  if (!configJson) return null
  
  try {
    return JSON.parse(configJson)
  } catch (error) {
    console.error('[orchestra] Invalid MCP_API_KEYS_JSON format:', error)
    return null
  }
}

/**
 * レート制限チェック
 */
async function checkRateLimit(keyId: string | null, tool: string): Promise<RateLimitResult> {
  const rateLimitEnabled = process.env.MCP_RATE_LIMIT_ENABLED === 'true'
  
  if (!rateLimitEnabled) {
    return {
      allowed: true,
      remaining: 999,
      resetTime: new Date(Date.now() + 60000),
      limit: 999
    }
  }
  
  const limit = keyId 
    ? parseInt(process.env.MCP_RATE_LIMIT_PER_MIN || '60')
    : parseInt(process.env.MCP_RATE_LIMIT_ANON_PER_MIN || '10')
  
  const identifier = keyId || 'anonymous'
  
  try {
    const { data, error } = await supabase.rpc('increment_rate_limit', {
      p_key_id: identifier,
      p_tool: tool,
      p_limit: limit
    })
    
    if (error) {
      console.error('[orchestra] Rate limit check failed:', error.message)
      // フェイルオープン: エラー時は通す
      return {
        allowed: true,
        remaining: limit,
        resetTime: new Date(Date.now() + 60000),
        limit
      }
    }
    
    const currentMinute = Math.floor(Date.now() / 60000)
    const resetTime = new Date((currentMinute + 1) * 60000)
    
    return {
      allowed: data.allowed,
      remaining: Math.max(0, limit - data.current_count),
      resetTime,
      limit
    }
  } catch (error: any) {
    console.error('[orchestra] Rate limit error:', error.message)
    // フェイルオープン: エラー時は通す
    return {
      allowed: true,
      remaining: limit,
      resetTime: new Date(Date.now() + 60000),
      limit
    }
  }
}

/**
 * DB管理型APIキー検証
 */
async function lookupApiKey(presentedKey: string | null): Promise<ApiKeyData | null> {
  if (!presentedKey) return null
  
  const pepper = process.env.MCP_API_PEPPER
  if (!pepper) {
    console.error('[orchestra] MCP_API_PEPPER not configured for DB keys')
    return null
  }
  
  try {
    const keyHash = crypto
      .createHmac('sha256', pepper)
      .update(presentedKey)
      .digest('base64')
    
    const { data, error } = await supabase
      .from('mcp_api_keys')
      .select('id, scopes, projects, name, last_used_at, expires_at')
      .eq('key_hash', keyHash)
      .eq('is_active', true)
      .single()
      
    if (error || !data) {
      console.debug('[orchestra] DB API key lookup failed:', error?.message || 'not found')
      return null
    }
    
    // 有効期限チェック
    if (data.expires_at && new Date(data.expires_at) < new Date()) {
      console.warn('[orchestra] DB API key expired:', data.name)
      return null
    }
    
    // 最終使用日時更新（非同期・エラー無視）
    supabase
      .from('mcp_api_keys')
      .update({ last_used_at: new Date().toISOString() })
      .eq('id', data.id)
      .then(({ error }) => {
        if (error) {
          console.debug('[orchestra] Failed to update last_used_at:', error.message)
        }
      })
    
    console.debug('[orchestra] DB API key validated:', { 
      id: data.id, 
      name: data.name,
      scopeCount: data.scopes?.length || 0 
    })
    
    return {
      id: data.id,
      scopes: data.scopes || [],
      projects: data.projects || [],
      name: data.name
    }
  } catch (error: any) {
    console.error('[orchestra] DB API key lookup error:', error.message)
    return null
  }
}

/**
 * APIキー検証（DB優先・ENV fallback）
 */
async function validateApiKey(apiKey: string | null): Promise<{
  valid: boolean
  scopes: Scope[]
  keyId?: string
  projects?: string[]
  source: 'db' | 'env' | 'dev'
}> {
  const requireApiKey = process.env.MCP_REQUIRE_API_KEY === 'true'
  const dbKeysEnabled = process.env.MCP_DB_KEYS_ENABLED === 'true'
  
  // 開発モード：APIキー要求無効時は全権限
  if (!requireApiKey) {
    return { 
      valid: true, 
      scopes: ['archive:write', 'archive:read', 'board:read', 'board:write', 'logs:write'],
      source: 'dev'
    }
  }
  
  // APIキー未提供
  if (!apiKey) {
    return { valid: false, scopes: [], source: 'env' }
  }
  
  // DB管理型APIキー優先チェック
  if (dbKeysEnabled) {
    const keyData = await lookupApiKey(apiKey)
    if (keyData) {
      return {
        valid: true,
        scopes: keyData.scopes as Scope[],
        keyId: keyData.id,
        projects: keyData.projects,
        source: 'db'
      }
    }
    
    console.debug('[orchestra] DB key not found, trying ENV fallback')
  }
  
  // ENV管理型APIキー fallback
  const config = getApiKeyConfig()
  if (!config || !config[apiKey]) {
    return { valid: false, scopes: [], source: 'env' }
  }
  
  console.debug('[orchestra] ENV API key validated:', { scopeCount: config[apiKey].length })
  
  return { 
    valid: true, 
    scopes: config[apiKey],
    source: 'env'
  }
}

function hasRequiredScope(scopes: Scope[], requiredScope: Scope): boolean {
  return scopes.includes(requiredScope)
}

interface ToolCallRequest {
  tool: string
  args?: Record<string, any>
}

/**
 * 統一エラーレスポンス作成
 */
function createErrorResponse(
  code: string, 
  message: string, 
  requestId: string,
  status: number = 500
): NextResponse {
  return NextResponse.json({
    error: {
      code,
      message,
      requestId,
      timestamp: new Date().toISOString()
    }
  }, { status })
}

/**
 * レート制限エラーレスポンス作成
 */
function createRateLimitResponse(
  requestId: string,
  rateLimitResult: RateLimitResult
): NextResponse {
  const response = NextResponse.json({
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'Too many requests. Please wait before trying again.',
      requestId,
      timestamp: new Date().toISOString(),
      rateLimit: {
        limit: rateLimitResult.limit,
        remaining: rateLimitResult.remaining,
        resetTime: rateLimitResult.resetTime.toISOString(),
        retryAfter: Math.ceil((rateLimitResult.resetTime.getTime() - Date.now()) / 1000)
      }
    }
  }, { status: 429 })
  
  // Rate limiting headers
  response.headers.set('X-RateLimit-Limit', rateLimitResult.limit.toString())
  response.headers.set('X-RateLimit-Remaining', rateLimitResult.remaining.toString())
  response.headers.set('X-RateLimit-Reset', Math.ceil(rateLimitResult.resetTime.getTime() / 1000).toString())
  response.headers.set('Retry-After', Math.ceil((rateLimitResult.resetTime.getTime() - Date.now()) / 1000).toString())
  
  return response
}

/**
 * 統一成功レスポンス作成
 */
function createSuccessResponse(
  tool: string,
  result: any,
  requestId: string
): NextResponse {
  return NextResponse.json({
    success: true,
    tool,
    result,
    requestId,
    metadata: {
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    }
  }, { status: 200 })
}

export async function POST(req: NextRequest) {
  const requestId = generateRequestId()
  const startTime = Date.now()
  
  // ヘッダー抽出
  const apiKey = req.headers.get('x-api-key')
  const agentId = req.headers.get('x-agent-id') ?? 'unknown'
  const sessionId = req.headers.get('x-session-id') ?? 'unknown'
  const idempotencyKey = req.headers.get('x-idempotency-key')

  const logContext: LogContext = {
    requestId,
    agentId,
    sessionId
  }

  try {
    await auditLog('info', 'MCP Tools実行開始', {
      ...logContext,
      hasApiKey: !!apiKey,
      hasIdempotencyKey: !!idempotencyKey,
      stage: 5
    })

    // APIキー検証（DB優先・ENV fallback）
    const { valid, scopes, keyId, projects, source } = await validateApiKey(apiKey)
    
    if (!valid) {
      await auditLog('error', 'APIキー認証失敗', {
        ...logContext,
        hasApiKey: !!apiKey,
        requireApiKey: process.env.MCP_REQUIRE_API_KEY === 'true',
        dbKeysEnabled: process.env.MCP_DB_KEYS_ENABLED === 'true'
      })
      return createErrorResponse('UNAUTHORIZED', 'Invalid or missing API key', requestId, 401)
    }

    await auditLog('info', 'APIキー認証成功', {
      ...logContext,
      scopeCount: scopes.length,
      scopes: scopes.join(','),
      keySource: source,
      keyId: keyId || 'env-managed',
      projectCount: projects?.length || 0
    })

    // リクエストボディ解析
    const { tool, args }: ToolCallRequest = await req.json()
    
    if (!tool) {
      await auditLog('error', 'ツール名未指定', logContext)
      return createErrorResponse('MISSING_TOOL', 'Tool name is required', requestId, 400)
    }

    logContext.tool = tool
    logContext.args = args

    // ツール別スコープチェック
    let requiredScope: Scope
    switch (tool) {
      case 'archive.create':
        requiredScope = 'archive:write'
        break
      case 'archive.list':
        requiredScope = 'archive:read'
        break
      case 'board.list':
        requiredScope = 'board:read'
        break
      case 'board.update':
        requiredScope = 'board:write'
        break
      case 'logs.write':
        requiredScope = 'logs:write'
        break
      default:
        await auditLog('error', '未知のツール', { ...logContext, tool })
        return createErrorResponse('UNKNOWN_TOOL', `Tool '${tool}' is not available`, requestId, 400)
    }

    if (!hasRequiredScope(scopes, requiredScope)) {
      await auditLog('error', 'スコープ権限不足', {
        ...logContext,
        requiredScope,
        availableScopes: scopes.join(','),
        keySource: source
      })
      return createErrorResponse('FORBIDDEN', `Insufficient scope for tool '${tool}'. Required: ${requiredScope}`, requestId, 403)
    }

    // プロジェクト権限チェック（DBキーのみ）
    if (source === 'db' && projects && projects.length > 0) {
      const projectId = args?.projectId
      if (projectId && !projects.includes(projectId)) {
        await auditLog('error', 'プロジェクト権限不足', {
          ...logContext,
          requestedProject: projectId,
          allowedProjects: projects.join(',')
        })
        return createErrorResponse('FORBIDDEN', `Access denied for project ${projectId}`, requestId, 403)
      }
    }

    // レート制限チェック（Stage 5 Phase 2）
    const rateLimitResult = await checkRateLimit(keyId || null, tool)
    
    if (!rateLimitResult.allowed) {
      await auditLog('warn', 'レート制限超過', {
        ...logContext,
        rateLimitExceeded: true,
        remaining: rateLimitResult.remaining,
        limit: rateLimitResult.limit,
        resetTime: rateLimitResult.resetTime.toISOString(),
        keySource: source
      })
      return createRateLimitResponse(requestId, rateLimitResult)
    }

    await auditLog('info', `ツール実行準備: ${tool}`, {
      ...logContext,
      requiredScope,
      keySource: source,
      rateLimitRemaining: rateLimitResult.remaining,
      rateLimitLimit: rateLimitResult.limit
    })

    // 冪等性チェック
    if (idempotencyKey) {
      const cachedResponse = await checkIdempotency(tool, idempotencyKey)
      
      if (cachedResponse) {
        await auditLog('info', '冪等性キャッシュヒット', {
          ...logContext,
          idempotencyKey,
          cached: true
        })
        
        return NextResponse.json({
          ...cachedResponse,
          requestId,
          metadata: {
            ...cachedResponse.metadata,
            cached: true,
            originalTimestamp: cachedResponse.metadata?.timestamp,
            timestamp: new Date().toISOString()
          }
        }, { status: 200 })
      }
    }

    // ツール実行
    let result: any

    switch (tool) {
      case 'archive.create': {
        const { title, structureSnapshot } = args ?? {}
        
        if (!title || !structureSnapshot) {
          await auditLog('error', 'archive.create 引数不足', {
            ...logContext,
            hasTitle: !!title,
            hasSnapshot: !!structureSnapshot
          })
          return createErrorResponse('INVALID_ARGS', 'title and structureSnapshot are required', requestId, 400)
        }
        
        await auditLog('info', 'Archive作成開始', {
          ...logContext,
          title,
          tasksCount: structureSnapshot.tasks?.length || 0
        })

        const { data, error } = await supabase
          .from('v2_project_archives')
          .insert({
            title,
            structure_snapshot: structureSnapshot,
            user_id: null  // TODO: 認証システム実装時に auth.uid() に変更
          })
          .select('id, title, created_at')
          .single()
          
        if (error) {
          await auditLog('error', 'Archive作成失敗', {
            ...logContext,
            error: error.message,
            errorCode: error.code
          })
          return createErrorResponse('ARCHIVE_CREATE_FAILED', error.message, requestId)
        }

        result = {
          id: data.id,
          title: data.title,
          created_at: data.created_at,
          message: 'Archive created successfully'
        }
        break
      }

      case 'archive.list': {
        const { limit = 10 } = args ?? {}
        
        await auditLog('info', 'Archive一覧取得開始', {
          ...logContext,
          limit
        })

        const { data, error } = await supabase
          .from('v2_project_archives')
          .select('id, title, structure_snapshot, created_at')
          .order('created_at', { ascending: false })
          .limit(Math.min(limit, 100))
          
        if (error) {
          await auditLog('error', 'Archive一覧取得失敗', {
            ...logContext,
            error: error.message
          })
          return createErrorResponse('ARCHIVE_LIST_FAILED', error.message, requestId)
        }

        result = {
          archives: data || [],
          total: data?.length || 0,
          limit
        }
        break
      }
      
      case 'board.list': {
        await auditLog('info', 'Board一覧取得開始', logContext)

        const { data, error } = await supabase
          .from('v2_project_archives')
          .select('id, title, structure_snapshot, created_at')
          .order('created_at', { ascending: false })
          .limit(10)
          
        if (error) {
          await auditLog('error', 'Board一覧取得失敗', {
            ...logContext,
            error: error.message
          })
          return createErrorResponse('BOARD_LIST_FAILED', error.message, requestId)
        }

        result = {
          archives: data || [],
          count: data?.length || 0,
          latest: data?.[0] || null
        }
        break
      }

      case 'board.update': {
        const { id, patch } = args ?? {}
        
        if (!id || !patch) {
          await auditLog('error', 'board.update 引数不足', {
            ...logContext,
            hasId: !!id,
            hasPatch: !!patch
          })
          return createErrorResponse('INVALID_ARGS', 'id and patch are required', requestId, 400)
        }

        await auditLog('info', 'Board更新開始', {
          ...logContext,
          id,
          patchKeys: Object.keys(patch).join(',')
        })

        const { data, error } = await supabase
          .from('v2_project_archives')
          .update(patch)
          .eq('id', id)
          .select('id, title, created_at, updated_at')
          .single()

        if (error) {
          await auditLog('error', 'Board更新失敗', {
            ...logContext,
            error: error.message,
            errorCode: error.code
          })
          return createErrorResponse('BOARD_UPDATE_FAILED', error.message, requestId)
        }

        result = {
          updated: data,
          message: 'Board updated successfully'
        }
        break
      }

      case 'logs.write': {
        const { level, message, context } = args ?? {}
        
        if (!level || !message) {
          await auditLog('error', 'logs.write 引数不足', {
            ...logContext,
            hasLevel: !!level,
            hasMessage: !!message
          })
          return createErrorResponse('INVALID_ARGS', 'level and message are required', requestId, 400)
        }

        await auditLog(level, message, {
          ...logContext,
          externalWrite: true,
          ...context
        })

        result = {
          id: requestId,
          level,
          message,
          context,
          timestamp: new Date().toISOString()
        }
        break
      }
      
      default:
        await auditLog('error', '未知のツール', { ...logContext, tool })
        return createErrorResponse('UNKNOWN_TOOL', `Tool '${tool}' is not available`, requestId, 400)
    }
    
    const duration = Date.now() - startTime
    
    await auditLog('info', 'ツール実行成功', {
      ...logContext,
      duration,
      resultType: typeof result,
      keySource: source,
      rateLimitRemaining: rateLimitResult.remaining
    })

    const response = createSuccessResponse(tool, result, requestId)
    
    // レート制限ヘッダー追加
    response.headers.set('X-RateLimit-Limit', rateLimitResult.limit.toString())
    response.headers.set('X-RateLimit-Remaining', rateLimitResult.remaining.toString())
    response.headers.set('X-RateLimit-Reset', Math.ceil(rateLimitResult.resetTime.getTime() / 1000).toString())
    
    // 冪等性レスポンス保存
    if (idempotencyKey) {
      const responseData = await response.clone().json()
      await saveIdempotencyResponse(tool, idempotencyKey, responseData)
      
      await auditLog('debug', '冪等性レスポンス保存', {
        ...logContext,
        idempotencyKey
      })
    }
    
    return response
    
  } catch (error: any) {
    const duration = Date.now() - startTime
    
    await auditLog('error', 'ツール実行エラー', {
      ...logContext,
      error: error.message,
      duration
    })
    
    return createErrorResponse('TOOL_EXECUTION_FAILED', error.message || 'Unknown error occurred', requestId)
  }
}